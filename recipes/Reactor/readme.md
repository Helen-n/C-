#### 基本概念
在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
- 什么是阻塞和非阻塞
  - 阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式。

  - 阻塞方式下读取或者写入函数将一直等待。

  - 非阻塞方式下，读取或者写入函数会立即返回一个状态值。
- 什么是同步和异步
  - 同步和异步是针对应用程序和内核的交互而言的。

  - 同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。

  - 异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。

 一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。
   - 同步阻塞 IO：
      - 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。

   - 同步非阻塞IO:
      - 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。

   - 异步阻塞IO：
     - 此种方式下,应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性
#### Reactor和Peactor
 - Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分离者等待某个事件或者是应用或者是某个操作的状态发生（比如文件描述符可读写，或者是socket可读写）,事件分离者就把这个事件传给事先注册的事件处理器或者事件处理函数或者回调函数，由后者来做实际的读写操作。

 - 而在Proactor模式中，事件处理器(或者由事件分离器代为)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理器或者事件处理函数或者回调。
 
 - Reactor
   - 某个事件处理器宣称它对某个socket上的读事件很感兴趣；
   - 事件分离者等着这个事件的发生；
   - 当事件发生了，事件分离器被唤醒，这负责通知先前那个事件处理器；
   - 事件处理器收到消息，于是去那个socket上读数据了. 如果需要，它再次宣称对这个socket上的读事件感兴趣，一直重复上面的步骤；

#### Reactor的简单实现
- 简单实现设计
![image](https://raw.githubusercontent.com/Helen-n/miniWebServer/master/images/reactor1.jpg)
- 添加定时器，增加定时实现任务的功能
![image](https://raw.githubusercontent.com/Helen-n/miniWebServer/master/images/reactor2.jpg)
---
#### reference
[基于ACE Proactor框架下高并发、大容量吞吐程序设计既最近的一个产品开发总结](https://my.oschina.net/JJREN/blog/51966)
[使用c++简单实现reactor模式](https://blog.csdn.net/baidu20008/article/details/41378761)